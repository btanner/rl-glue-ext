<html><head><title>Package Cl-Ppcre [Tinaa]</title><link rel="stylesheet" href="../tinaa.css" /></head><body><div id="header"><a class="contents-link" href="../index.html" title="Go to contents">Contents</a><div class="index-links"><div class="index">Indexes:</div><div class="index"><a href="index-of-class.html">Class</a></div><div class="index"><a href="index-of-condition.html">Condition</a></div><div class="index"><a href="index-of-variable.html">Variable</a></div><div class="index"><a href="index-of-function.html">Function</a></div><div class="index"><a href="index-of-macro.html">Macro</a></div><div class="index"><a href="index-of-symbol.html">Symbol</a></div><div class="index"><a href="index-of-permuted-symbols.html">Permuted</a></div></div></div><div class="contents"><h2>Package Cl-Ppcre - internal and external symbols</h2><div class="part-parents"><h3>Part of:</h3><a href="../rl-glue-utils-asdf-system/index.html">asdf-system rl-glue-utils</a>, <a href="../cl-ppcre-asdf-system/index.html">asdf-system cl-ppcre</a></div><div class="package-symbols">See only <a href="index.html">external symbols</a></div><div class="part-summary">Package Cl-Ppcre uses the packages Common-Lisp.  It is also known as Ppcre.  It has 417 total symbols and 31 external ones.</div><div class="table-summary"><h3>Condition</h3><table id="condition"><tr class="oddrow"><th><a href="../cl-ppcre-package/condition-ppcre--error.html">ppcre-error</a></th><td>All errors signaled by CL-PPCRE are of<br>this type.</td></tr><tr class=""><th><a href="../cl-ppcre-package/condition-ppcre--invocation--error.html">ppcre-invocation-error</a></th><td>Signaled when CL-PPCRE functions are<br>invoked with wrong arguments.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/condition-ppcre--syntax--error.html">ppcre-syntax-error</a></th><td>Signaled if CL-PPCRE&#39;s parser encounters an error<br>when trying to parse a regex string or to conve...</td></tr></table></div><div class="table-summary"><h3>Class</h3><table id="class"><tr class="oddrow"><th><a href="../cl-ppcre-package/class-alternation.html">alternation</a></th><td>ALTERNATION objects represent alternations of<br>regexes.  (Like &#147;a|b&#148; ist the alternation of &#147;a&#148; or...</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-anchor.html">anchor</a></th><td>ANCHOR objects represent anchors like &#147;^&#148; or &#147;$&#148;.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-back--reference.html">back-reference</a></th><td>BACK-REFERENCE objects represent backreferences.</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-branch.html">branch</a></th><td>BRANCH objects represent Perl&#39;s conditional regular<br>expressions.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-char--class.html">char-class</a></th><td>CHAR-CLASS objects represent character classes.</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-everything.html">everything</a></th><td>EVERYTHING objects represent regexes matching<br>&#147;everything&#148;, i.e. dots.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-filter.html">filter</a></th><td>FILTER objects represent arbitrary functions<br>defined by the user.</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-lookahead.html">lookahead</a></th><td>LOOKAHEAD objects represent look-ahead assertions.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-lookbehind.html">lookbehind</a></th><td>LOOKBEHIND objects represent look-behind assertions.</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-regex.html">regex</a></th><td>The REGEX base class.  All other classes inherit<br>from this one.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-register.html">register</a></th><td>REGISTER objects represent register groups.</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-repetition.html">repetition</a></th><td>REPETITION objects represent repetitions of regexes.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-seq.html">seq</a></th><td>SEQ objects represents sequences of regexes.<br>(Like &#147;ab&#148; is the sequence of &#147;a&#148; and &#147;b&#148;.)</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-standalone.html">standalone</a></th><td>A standalone regular expression.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-str.html">str</a></th><td>STR objects represent string.</td></tr><tr class=""><th><a href="../cl-ppcre-package/class-void.html">void</a></th><td>VOID objects represent empty regular expressions.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/class-word--boundary.html">word-boundary</a></th><td>WORD-BOUNDARY objects represent word-boundary assertions.</td></tr></table></div><div class="table-summary"><h3>Variable</h3><table id="variable"><tr class="oddrow"><th><a href="../cl-ppcre-package/variable--callow--named--registers-c.html">*allow-named-registers*</a></th><td>Whether the parser should support AllegroCL&#39;s named registers<br>(?&lt;name&gt;&#147;&lt;regex&gt;&#148;) and back-referen...</td></tr><tr class=""><th>*allow-quoting*</th><td>Whether the parser should support Perl&#39;s \Q and \E.</td></tr><tr class="oddrow"><th>*end-pos*</th><td>Where to stop scanning within *STRING*.</td></tr><tr class=""><th>*end-string-pos*</th><td>Start of the next possible end-string candidate.</td></tr><tr class="oddrow"><th>*extended-mode-p*</th><td>Whether the parser will start in extended mode.</td></tr><tr class=""><th>*hyperdoc-base-uri*</th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/variable--clast--pos--stores-c.html">*last-pos-stores*</a></th><td>An array to keep track of the last positions<br>where we saw repetitive patterns.<br>Only used for patt...</td></tr><tr class=""><th><a href="../cl-ppcre-package/variable--coptimize--char--classes-c.html">*optimize-char-classes*</a></th><td>Whether character classes should be compiled into look-ups into<br>O(1) data structures.  This is us...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/variable--cproperty--resolver-c.html">*property-resolver*</a></th><td>Should be NIL or a designator for a function which accepts strings<br>and returns unary character te...</td></tr><tr class=""><th>*real-start-pos*</th><td>The real start of *STRING*. This is for repeated scans and is only used internally.</td></tr><tr class="oddrow"><th>*reg-ends*</th><td>An array which holds the end positions<br>of the current register candidates.</td></tr><tr class=""><th>*reg-starts*</th><td>An array which holds the start positions<br>of the current register candidates.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/variable--cregex--char--code--limit-c.html">*regex-char-code-limit*</a></th><td>The upper exclusive bound on the char-codes of characters which can<br>occur in character classes.  ...</td></tr><tr class=""><th>*regs-maybe-start*</th><td>An array which holds the next start positions<br>of the current register candidates.</td></tr><tr class="oddrow"><th>*rep-num*</th><td>Counts the number of &#147;complicated&#148; repetitions while the matchers<br>are built.</td></tr><tr class=""><th>*repeat-counters*</th><td>An array to keep track of how often<br>repetitive patterns have been tested already.</td></tr><tr class="oddrow"><th>*special-optimize-settings*</th><td>Special optimize settings used only by a few declaration expressions.</td></tr><tr class=""><th>*standard-optimize-settings*</th><td>The standard optimize settings used by most declaration expressions.</td></tr><tr class="oddrow"><th>*start-pos*</th><td>Where to start scanning within *STRING*.</td></tr><tr class=""><th>*string*</th><td>The string which is currently scanned by SCAN.<br>Will always be coerced to a SIMPLE-STRING.</td></tr><tr class="oddrow"><th>*syntax-error-string*</th><td>The string which caused the syntax error.</td></tr><tr class=""><th><a href="../cl-ppcre-package/variable--cuse--bmh--matchers-c.html">*use-bmh-matchers*</a></th><td>Whether the scanners created by CREATE-SCANNER should use the (fast<br>but large) Boyer-Moore-Horspo...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/variable--czero--length--num-c.html">*zero-length-num*</a></th><td>Counts the number of repetitions the inner regexes of which may<br>have zero-length while the matche...</td></tr><tr class=""><th>reg-seen</th><td></td></tr></table></div><div class="table-summary"><h3>Constant</h3><table id="constant"><tr class="oddrow"><th><a href="../cl-ppcre-package/constant-+probe--depth+.html">+probe-depth+</a></th><td>Maximum number of collisions (for any element) we accept before we<br>allocate more storage.  This i...</td></tr><tr class=""><th>+whitespace-char-string+</th><td>A string of all characters which are considered to be whitespace.<br>Same as Perl&#39;s [\s].</td></tr></table></div><div class="table-summary"><h3>Function</h3><table id="function"><tr class="oddrow"><th><a href="../cl-ppcre-package/function-%add--to--charset.html">%add-to-charset</a></th><td>Tries to add the character CHAR to the charset SET without<br>extending it.  Returns NIL if this fai...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-%add--to--charset-bexpand.html">%add-to-charset/expand</a></th><td>Extends the charset SET and then adds the character CHAR to it.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function--cstring-c--equal.html">*string*-equal</a></th><td>Like STRING-EQUAL, i.e. compares the special string *STRING* from<br>START1 to END1 with STRING2 fro...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function--cstring-c=.html">*string*=</a></th><td>Like STRING=, i.e. compares the special string *STRING* from START1<br>to END1 with STRING2 from STA...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-add--to--charset.html">add-to-charset</a></th><td>Adds the character CHAR to the charset SET, extending SET if<br>necessary.  Returns CHAR.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-all--matches.html">all-matches</a></th><td>Returns a list containing the start and end positions of all<br>matches of REGEX against TARGET-STRI...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-all--matches--as--strings.html">all-matches-as-strings</a></th><td>Returns a list containing all substrings of TARGET-STRING which<br>match REGEX. If REGEX matches an ...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-build--replacement.html">build-replacement</a></th><td>Accepts a replacement template and the current values from the<br>matching process in REGEX-REPLACE ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-charmap--complementp.html">charmap-complementp</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-charmap--contents.html">charmap-contents</a></th><td>Returns a list of all characters belonging to a character map.<br>Only works for non-complement char...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-charmap--count.html">charmap-count</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-charmap--end.html">charmap-end</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-charmap--p.html">charmap-p</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-charmap--start.html">charmap-start</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-charmap--vector.html">charmap-vector</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-charset--count.html">charset-count</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-charset--depth.html">charset-depth</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-charset--p.html">charset-p</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-charset--vector.html">charset-vector</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-clean--comments.html">clean-comments</a></th><td>Clean (?#...) comments within STRING for quoting, i.e. convert<br>\Q to Q and \E to E.  If EXTENDED-...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-collect--char--class.html">collect-char-class</a></th><td>Reads and consumes characters from regex string until a right<br>bracket is seen.  Assembles them in...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-complement-c.html">complement*</a></th><td>Like COMPLEMENT but optimized for unary functions.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-compute--index.html">compute-index</a></th><td>Computes and returns the index into the vector VECTOR corresponding<br>to the hash code HASH.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-convert.html">convert</a></th><td>Converts the parse tree PARSE-TREE into an equivalent REGEX object<br>and returns three values: the ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-convert--aux.html">convert-aux</a></th><td>Converts the parse tree PARSE-TREE into a REGEX object and returns<br>it.  Will also<br><br>  - split and ...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-convert--char--class--to--test--function.html">convert-char-class-to-test-function</a></th><td>Combines all items in LIST into test function and returns a<br>logical-OR combination of these funct...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-copy--charmap.html">copy-charmap</a></th><td>Return a copy of STRUCTURE with the same (EQL) slot values.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-copy--charset.html">copy-charset</a></th><td>Return a copy of STRUCTURE with the same (EQL) slot values.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-copy--lexer.html">copy-lexer</a></th><td>Return a copy of STRUCTURE with the same (EQL) slot values.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-create--bmh--matcher.html">create-bmh-matcher</a></th><td>Returns a Boyer-Moore-Horspool matcher which searches the (special)<br>simple-string *STRING* for th...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-create--char--searcher.html">create-char-searcher</a></th><td>Returns a function which searches the (special) simple-string<br>*STRING* for the first occurence of...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-create--charmap--from--test--function.html">create-charmap-from-test-function</a></th><td>Creates and returns a charmap representing all characters with<br>character codes between START and ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-create--charset--from--test--function.html">create-charset-from-test-function</a></th><td>Creates and returns a charset representing all characters with<br>character codes between START and ...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-create--greedy--everything--matcher.html">create-greedy-everything-matcher</a></th><td>Creates a closure which just matches as far ahead as possible,<br>i.e. a closure for a dot in single...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-create--hash--table--from--test--function.html">create-hash-table-from-test-function</a></th><td>Creates and returns a hash table representing all characters with<br>character codes between START a...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-create--optimized--test--function.html">create-optimized-test-function</a></th><td>Given a unary test function which is applicable to characters<br>returns a function which yields the...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-create--scanner--aux.html">create-scanner-aux</a></th><td>Auxiliary function to create and return a scanner (which is<br>actually a closure).  Used by CREATE-...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-digit--char--p.html">digit-char-p</a></th><td>Tests whether a character is a decimal digit, i.e. the same as<br>Perl&#39;s [\d].  Note that this funct...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-end--of--string--p.html">end-of-string-p</a></th><td>Tests whether we&#39;re at the end of the regex string.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-end--string.html">end-string</a></th><td>Returns the constant string (if it exists) REGEX ends with wrapped<br>into a STR object, otherwise N...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-fail.html">fail</a></th><td>Moves (LEXER-POS LEXER) back to the last position stored in<br>(LEXER-LAST-POS LEXER) and pops the L...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-get--number.html">get-number</a></th><td>Read and consume the number the lexer is currently looking at and<br>return it. Returns NIL if no nu...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-get--quantifier.html">get-quantifier</a></th><td>Returns a list of two values (min max) if what the lexer is looking<br>at can be interpreted as a qu...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-get--token.html">get-token</a></th><td>Returns and consumes the next token from the regex string (or NIL).</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-greedy--quant.html">greedy-quant</a></th><td>Parses and consumes a &lt;greedy-quant&gt;.<br>The productions are: &lt;greedy-quant&gt; -&gt; &lt;group&gt; | &lt;group&gt;&lt;qu...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-group.html">group</a></th><td>Parses and consumes a &lt;group&gt;.<br>The productions are: &lt;group&gt; -&gt; &#147;(&#148;&lt;regex&gt;&#147;)&#148;<br>                    ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-hyperdoc--lookup.html">hyperdoc-lookup</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-in--charmap--p.html">in-charmap-p</a></th><td>Tests whether the character CHAR belongs to the set represented by CHARMAP.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-in--charset--p.html">in-charset-p</a></th><td>Checks whether the character CHAR is in the charset SET.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-lexer--last--pos.html">lexer-last-pos</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-lexer--len.html">lexer-len</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-lexer--p.html">lexer-p</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-lexer--pos.html">lexer-pos</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-lexer--reg.html">lexer-reg</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-lexer--str.html">lexer-str</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-looking--at--p.html">looking-at-p</a></th><td>Tests whether the next character the lexer would see is CHR.<br>Does not respect extended mode.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-make--char--from--code.html">make-char-from-code</a></th><td>Create character from char-code NUMBER. NUMBER can be NIL<br>which is interpreted as 0. ERROR-POS is...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-make--char--vector.html">make-char-vector</a></th><td>Returns a vector of size SIZE to hold characters.  All elements are<br>initialized to #Null except f...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-make--charmap.html">make-charmap</a></th><td>Creates and returns a charmap representing all characters with<br>character codes in the interval [s...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-make--charmap%.html">make-charmap%</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-make--charset.html">make-charset</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-make--lexer.html">make-lexer</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-make--lexer--internal.html">make-lexer-internal</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/function-map--char--to--special--char--class.html">map-char-to-special-char-class</a></th><td>Maps escaped characters like &#147;\d&#148; to the tokens which represent<br>their associated character classe...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-map--charset.html">map-charset</a></th><td>Calls FUNCTION with all characters in SET.  Returns NIL.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-maybe--accumulate.html">maybe-accumulate</a></th><td>Accumulate STR into the special variable STARTS-WITH if<br>ACCUMULATE-START-P (also special) is true...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-maybe--parse--flags.html">maybe-parse-flags</a></th><td>Reads a sequence of modifiers (including #\- to reverse their<br>meaning) and returns a correspondin...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-maybe--split--repetition.html">maybe-split-repetition</a></th><td>Splits a REPETITION object into a constant and a varying part if<br>applicable, i.e. something like<br>...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-mix.html">mix</a></th><td>Given a character code CODE and a hash code HASH, computes and<br>returns the &#147;next&#148; hash code.  See...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-newline--skipper.html">newline-skipper</a></th><td>Finds the next occurence of a character in *STRING* which is behind<br>a #Newline.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-next--char.html">next-char</a></th><td>Returns the next character which is to be examined and updates the<br>POS slot. Respects extended mo...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-next--char--non--extended.html">next-char-non-extended</a></th><td>Returns the next character which is to be examined and updates the<br>POS slot. Does not respect ext...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-normalize--var--list.html">normalize-var-list</a></th><td>Utility function for REGISTER-GROUPS-BIND and DO-REGISTER-GROUPS.<br>Creates the long form (a list o...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-nsubseq.html">nsubseq</a></th><td>Returns a subsequence by pointing to location in original sequence.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-parse--register--name--aux.html">parse-register-name-aux</a></th><td>Reads and returns the name in a named register group.  It is<br>assumed that the starting #&lt; charact...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-parse--string.html">parse-string</a></th><td>Translate the regex string STRING into a parse tree.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-parse--tree--synonym.html">parse-tree-synonym</a></th><td>Returns the parse tree the SYMBOL symbol is a synonym for.  Returns<br>NIL is SYMBOL wasn&#39;t yet defi...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-print--symbol--info.html">print-symbol-info</a></th><td>Auxiliary function used by REGEX-APROPOS. Tries to print some<br>meaningful information about a symb...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-quant.html">quant</a></th><td>Parses and consumes a &lt;quant&gt;.<br>The productions are: &lt;quant&gt; -&gt; &lt;greedy-quant&gt; | &lt;greedy-quant&gt;&#147;?&#148;...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-quote--meta--chars.html">quote-meta-chars</a></th><td>Quote, i.e. prefix with #\\, all non-word characters in STRING.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-quote--sections.html">quote-sections</a></th><td>Replace sections inside of STRING which are enclosed by \Q and<br>\E with the quoted equivalent of t...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-read--char--property.html">read-char-property</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-reg--expr.html">reg-expr</a></th><td>Parses and consumes a &lt;regex&gt;, a complete regular expression.<br>The productions are: &lt;regex&gt; -&gt; &lt;se...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-regex--apropos.html">regex-apropos</a></th><td>Similar to the standard function APROPOS but returns a list of all<br>symbols which match the regula...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-regex--apropos--list.html">regex-apropos-list</a></th><td>Similar to the standard function APROPOS-LIST but returns a list of<br>all symbols which match the r...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-regex--replace.html">regex-replace</a></th><td>Try to match TARGET-STRING between START and END against REGEX and<br>replace the first match with R...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-regex--replace--all.html">regex-replace-all</a></th><td>Try to match TARGET-STRING between START and END against REGEX and<br>replace all matches with REPLA...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-replace--aux.html">replace-aux</a></th><td>Auxiliary function used by REGEX-REPLACE and REGEX-REPLACE-ALL.<br>POS-LIST contains a list with the...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-reverse--strings.html">reverse-strings</a></th><td>Recursively walks through PARSE-TREE and destructively reverses all<br>strings in it.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-scan--to--strings.html">scan-to-strings</a></th><td>Like SCAN but returns substrings of TARGET-STRING instead of<br>positions, i.e. this function return...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-seq.html">seq</a></th><td>Parses and consumes a &lt;seq&gt;.<br>The productions are: &lt;seq&gt; -&gt; &lt;quant&gt; | &lt;quant&gt;&lt;seq&gt;.<br>Will return &lt;p...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-set--flag.html">set-flag</a></th><td>Reads a flag token and sets or unsets the corresponding entry in<br>the special FLAGS list.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-split.html">split</a></th><td>Matches REGEX against TARGET-STRING as often as possible and<br>returns a list of the substrings bet...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-start--of--subexpr--p.html">start-of-subexpr-p</a></th><td>Tests whether the next token can start a valid sub-expression, i.e.<br>a stand-alone regex.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-string--case--modifier.html">string-case-modifier</a></th><td>Checks whether all words in STR between FROM and TO are upcased,<br>downcased or capitalized and ret...</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-string--list--to--simple--string.html">string-list-to-simple-string</a></th><td>Concatenates a list of strings to one simple-string.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-try--number.html">try-number</a></th><td>Like GET-NUMBER but won&#39;t consume anything if no number is seen.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-unescape--char.html">unescape-char</a></th><td>Convert the characters(s) following a backslash into a token<br>which is returned. This function is ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-unget--token.html">unget-token</a></th><td>Moves the lexer back to the last position stored in the LAST-POS stack.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-whitespacep.html">whitespacep</a></th><td>Tests whether a character is whitespace, i.e. whether it would<br>match [\s] in Perl.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/function-word--boundary--p.html">word-boundary-p</a></th><td>Check whether START-POS is a word-boundary within *STRING*.</td></tr><tr class=""><th><a href="../cl-ppcre-package/function-word--char--p.html">word-char-p</a></th><td>Tests whether a character is a &#147;word&#148; character.  In the ASCII<br>charset this is equivalent to a-z,...</td></tr></table></div><div class="table-summary"><h3>Generic-Function</h3><table id="generic-function"><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-build--replacement--template.html">build-replacement-template</a></th><td>Converts a replacement string for REGEX-REPLACE or<br>REGEX-REPLACE-ALL into a replacement template ...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-case--mode.html">case-mode</a></th><td>Utility function used by the optimizer (see GATHER-STRINGS).<br>Returns a keyword denoting the case-...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-compute--min--rest.html">compute-min-rest</a></th><td>Returns the minimal length of REGEX plus<br>CURRENT-MIN-REST. This is similar to REGEX-MIN-LENGTH ex...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-compute--offsets.html">compute-offsets</a></th><td>Returns the offset the following regex would have<br>relative to START-POS or NIL if we can&#39;t comput...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-convert--compound--parse--tree.html">convert-compound-parse-tree</a></th><td>Helper function for CONVERT-AUX which converts<br>parse trees which are conses and dispatches on TOK...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-convert--simple--parse--tree.html">convert-simple-parse-tree</a></th><td>Helper function for CONVERT-AUX which converts<br>parse trees which are atoms.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-copy--regex.html">copy-regex</a></th><td>Implements a deep copy of a REGEX object.</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-create--constant--repetition--constant--length--matcher.html">create-constant-repetition-constant-length-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION has a constant n...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-create--constant--repetition--matcher.html">create-constant-repetition-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION has a constant n...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-create--greedy--constant--length--matcher.html">create-greedy-constant-length-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION is greedy and th...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-create--greedy--matcher.html">create-greedy-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION is greedy and th...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-create--greedy--no--zero--matcher.html">create-greedy-no-zero-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION is greedy and th...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-create--matcher--aux.html">create-matcher-aux</a></th><td>Creates a closure which takes one parameter,<br>START-POS, and tests whether REGEX can match *STRING...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-create--non--greedy--constant--length--matcher.html">create-non-greedy-constant-length-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION is non-greedy an...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-create--non--greedy--matcher.html">create-non-greedy-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION is non-greedy an...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-create--non--greedy--no--zero--matcher.html">create-non-greedy-no-zero-matcher</a></th><td>Creates a closure which tries to match REPETITION.<br>It is assumed that REPETITION is non-greedy an...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-create--scanner.html">create-scanner</a></th><td>Accepts a regular expression - either as a<br>parse-tree or as a string - and returns a scan closure...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-end--string--aux.html">end-string-aux</a></th><td>Returns the constant string (if it exists) REGEX<br>ends with wrapped into a STR object, otherwise N...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-everythingp.html">everythingp</a></th><td>Returns an EVERYTHING object if REGEX is equivalent<br>to this object, otherwise NIL.  So, &#147;(.){1}&#148; ...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-flatten.html">flatten</a></th><td>Merges adjacent sequences and alternations, i.e. it<br>transforms #&lt;SEQ #&lt;STR &#147;a&#148;&gt; #&lt;SEQ #&lt;STR &#147;b&#148;&gt; ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-gather--strings.html">gather-strings</a></th><td>Collects adjacent strings or characters into one<br>string provided they have the same case mode. Th...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-len.html">len</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-ppcre--syntax--error--pos.html">ppcre-syntax-error-pos</a></th><td>Returns the position within the string where the error occurred<br>(or NIL if the error happened whi...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-ppcre--syntax--error--string.html">ppcre-syntax-error-string</a></th><td>Returns the string the parser was parsing when the error was<br>encountered (or NIL if the error hap...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-regex--length.html">regex-length</a></th><td>Return the length of REGEX if it is fixed, NIL otherwise.</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-regex--min--length.html">regex-min-length</a></th><td>Returns the minimal length of REGEX.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-remove--registers.html">remove-registers</a></th><td>Returns a deep copy of a REGEX (see COPY-REGEX) and<br>optionally removes embedded REGISTER objects ...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-resolve--property.html">resolve-property</a></th><td>Resolves PROPERTY to a unary character test<br>function.  PROPERTY can either be a function designat...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-scan.html">scan</a></th><td>Searches TARGET-STRING from START to END and tries<br>to match REGEX.  On success returns four value...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-skip.html">skip</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-start--anchored--p.html">start-anchored-p</a></th><td>Returns T if REGEX starts with a &#147;real&#148; start<br>anchor, i.e. one that&#39;s not in multi-line mode, NIL...</td></tr><tr class=""><th><a href="../cl-ppcre-package/generic-efunction-start--of--end--string--p.html">start-of-end-string-p</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/generic-efunction-str.html">str</a></th><td></td></tr></table></div><div class="table-summary"><h3>Macro</h3><table id="macro"><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-bmh--matcher--aux.html">bmh-matcher-aux</a></th><td>Auxiliary macro used by CREATE-BMH-MATCHER.</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-case--insensitive--mode--p.html">case-insensitive-mode-p</a></th><td>Accessor macro to extract the first flag out of a three-element flag list.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-char--searcher--aux.html">char-searcher-aux</a></th><td>Auxiliary macro used by CREATE-CHAR-SEARCHER.</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-constant--repetition--constant--length--closure.html">constant-repetition-constant-length-closure</a></th><td>This is the template for simple constant repetitions (where simple<br>means that the inner regex to ...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-defconstant.html">defconstant</a></th><td>Make sure VALUE is evaluated only once (to appease SBCL).</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-define--parse--tree--synonym.html">define-parse-tree-synonym</a></th><td>Defines the symbol NAME to be a synonym for the parse tree<br>PARSE-TREE.  Both arguments are quoted...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-do--matches.html">do-matches</a></th><td>Iterates over TARGET-STRING and tries to match REGEX as often as<br>possible evaluating BODY with MA...</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-do--matches--as--strings.html">do-matches-as-strings</a></th><td>Iterates over TARGET-STRING and tries to match REGEX as often as<br>possible evaluating BODY with MA...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-do--register--groups.html">do-register-groups</a></th><td>Iterates over TARGET-STRING and tries to match REGEX as often as<br>possible evaluating BODY with th...</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-do--scans.html">do-scans</a></th><td>Iterates over TARGET-STRING and tries to match REGEX as often as<br>possible evaluating BODY with MA...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-greedy--constant--length--closure.html">greedy-constant-length-closure</a></th><td>This is the template for simple greedy repetitions (where simple<br>means that the minimum number of...</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-incf--after.html">incf-after</a></th><td>Utility macro inspired by C&#39;s &#147;place++&#148;, i.e. first return the<br>value of PLACE and afterwards incr...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-insert--advance--fn.html">insert-advance-fn</a></th><td>Creates the actual closure returned by CREATE-SCANNER-AUX by<br>replacing &#39;(ADVANCE-FN-DEFINITION) w...</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-insert--char--class--tester.html">insert-char-class-tester</a></th><td>Utility macro to replace each occurence of &#39;(CHAR-CLASS-TEST)<br>within BODY with the correct test (...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-maybe--coerce--to--simple--string.html">maybe-coerce-to-simple-string</a></th><td>Coerces STRING to a simple STRING unless it already is one.</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-multi--line--mode--p.html">multi-line-mode-p</a></th><td>Accessor macro to extract the second flag out of a three-element flag list.</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-non--greedy--constant--length--closure.html">non-greedy-constant-length-closure</a></th><td>This is the template for simple non-greedy repetitions (where<br>simple means that the minimum numbe...</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-regex--apropos--aux.html">regex-apropos-aux</a></th><td>Auxiliary macro used by REGEX-APROPOS and REGEX-APROPOS-LIST. Loops<br>through PACKAGES and executes...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-register--groups--bind.html">register-groups-bind</a></th><td>Executes BODY with the variables in VAR-LIST bound to the<br>corresponding register groups after TAR...</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-signal--invocation--error.html">signal-invocation-error</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-signal--syntax--error.html">signal-syntax-error</a></th><td></td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-signal--syntax--error-c.html">signal-syntax-error*</a></th><td></td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-single--line--mode--p.html">single-line-mode-p</a></th><td>Accessor macro to extract the third flag out of a three-element flag list.</td></tr><tr class=""><th><a href="../cl-ppcre-package/macro-with--rebinding.html">with-rebinding</a></th><td>WITH-REBINDING ( { var | (var prefix) }* ) form*<br><br>Evaluates a series of forms in the lexical envi...</td></tr><tr class="oddrow"><th><a href="../cl-ppcre-package/macro-with--unique--names.html">with-unique-names</a></th><td>Syntax: WITH-UNIQUE-NAMES ( { var | (var x) }* ) declaration* form*<br><br>Executes a series of forms w...</td></tr></table></div></div><div id="footer"><span class="date">Generated: Wed, Dec 3, 2008</span><span class="version">[Tinaa version 0.3]</span><a class="contents-link" href="../index.html" title="Go to contents">Contents</a><a id="tinaa-logo" href="http://common-lisp.net/project/tinaa/" title="Go to Tinaa home page"><img src="http://common-lisp.net/project/tinaa/images/logo.jpg" width="90" height="82" /></a></div></body></html>