<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>RL-Glue C/C++ Codec</TITLE>
<META NAME="description" CONTENT="RL-Glue C/C++ Codec">
<META NAME="keywords" CONTENT="doc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="doc.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.png">   
<BR>
<BR>
<BR>
<!--End of Navigation Panel-->
<H1 ALIGN="CENTER">RL-Glue C/C++ Codec 3.0 Manual <I>Revision</I>: 206</H1>
<DIV>

<P ALIGN="CENTER"><STRONG>Brian Tanner</STRONG></P>
<P ALIGN="CENTER"><STRONG><!-- MATH
 $Date: 2008-09-27 17:55:06 -0600 (Sat, 27 Sep 2008)$
 -->
<I>Date</I>: 2008-09-27 17:55:06 -0600 (<I>Sat</I>, 27 <I>Sep</I> 2008)</STRONG></P>
</DIV>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html47"
  HREF="doc.html#SECTION00020000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html48"
  HREF="doc.html#SECTION00021000000000000000">Software Requirements</A>
<LI><A NAME="tex2html49"
  HREF="doc.html#SECTION00022000000000000000">Getting the Codec</A>
<LI><A NAME="tex2html50"
  HREF="doc.html#SECTION00023000000000000000">Installing the Codec</A>
</UL>
<BR>
<LI><A NAME="tex2html51"
  HREF="doc.html#SECTION00030000000000000000">Agents</A>
<UL>
<LI><A NAME="tex2html52"
  HREF="doc.html#SECTION00031000000000000000">Custom Flags for Custom Installs</A>
</UL>
<BR>
<LI><A NAME="tex2html53"
  HREF="doc.html#SECTION00040000000000000000">Who creates and frees memory?</A>
<LI><A NAME="tex2html54"
  HREF="doc.html#SECTION00050000000000000000">Codec Specification Reference</A>
<UL>
<LI><A NAME="tex2html55"
  HREF="doc.html#SECTION00051000000000000000">Types</A>
<LI><A NAME="tex2html56"
  HREF="doc.html#SECTION00052000000000000000">Simple Types</A>
<LI><A NAME="tex2html57"
  HREF="doc.html#SECTION00053000000000000000">Structure Types</A>
<LI><A NAME="tex2html58"
  HREF="doc.html#SECTION00054000000000000000">Summary</A>
</UL>
<BR>
<LI><A NAME="tex2html59"
  HREF="doc.html#SECTION00060000000000000000">Changes and 2.x Backward Compatibility</A>
<UL>
<LI><A NAME="tex2html60"
  HREF="doc.html#SECTION00061000000000000000">Types</A>
<LI><A NAME="tex2html61"
  HREF="doc.html#SECTION00062000000000000000">C/C++ Environments</A>
</UL>
<BR>
<LI><A NAME="tex2html62"
  HREF="doc.html#SECTION00070000000000000000">Writing an Agent</A>
<UL>
<LI><A NAME="tex2html63"
  HREF="doc.html#SECTION00071000000000000000">C/C++ Agents</A>
</UL>
<BR>
<LI><A NAME="tex2html64"
  HREF="doc.html#SECTION00080000000000000000">Writing an Experiment</A>
<UL>
<LI><A NAME="tex2html65"
  HREF="doc.html#SECTION00081000000000000000">Basic Experiment Programs</A>
<LI><A NAME="tex2html66"
  HREF="doc.html#SECTION00082000000000000000">Advanced Experiment Programs</A>
<LI><A NAME="tex2html67"
  HREF="doc.html#SECTION00083000000000000000">Components Of A RL-Glue Experiment</A>
<LI><A NAME="tex2html68"
  HREF="doc.html#SECTION00084000000000000000">C/C++ Experiments</A>
<LI><A NAME="tex2html69"
  HREF="doc.html#SECTION00085000000000000000">Java Experiments</A>
<LI><A NAME="tex2html70"
  HREF="doc.html#SECTION00086000000000000000">Python Experiments</A>
<LI><A NAME="tex2html71"
  HREF="doc.html#SECTION00087000000000000000">Matlab Experiments</A>
</UL>
<BR>
<LI><A NAME="tex2html72"
  HREF="doc.html#SECTION00090000000000000000">Error Messages</A>
<LI><A NAME="tex2html73"
  HREF="doc.html#SECTION000100000000000000000">Command and Function Reference</A>
<UL>
<LI><A NAME="tex2html74"
  HREF="doc.html#SECTION000101000000000000000">Agent Functions</A>
<LI><A NAME="tex2html75"
  HREF="doc.html#SECTION000102000000000000000">Environment Functions</A>
<LI><A NAME="tex2html76"
  HREF="doc.html#SECTION000103000000000000000">Interface Routines Provided by the RL-Glue</A>
</UL>
<BR>
<LI><A NAME="tex2html77"
  HREF="doc.html#SECTION000110000000000000000">Frequently Asked Questions</A>
<LI><A NAME="tex2html78"
  HREF="doc.html#SECTION000120000000000000000">Glossary</A>
<LI><A NAME="tex2html79"
  HREF="doc.html#SECTION000130000000000000000">Credits and Acknowledgements</A>
<UL>
<LI><A NAME="tex2html80"
  HREF="doc.html#SECTION000131000000000000000">Contributing</A>
</UL></UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00020000000000000000">
Introduction</A>
</H1>
This document describes how to use the C/C++ RL-Glue Codec, a software library that provides socket-compatibility with the RL-Glue Reinforcement Learning software library.  

<P>
For general information and motivation about the RL-Glue<A NAME="tex2html1"
  HREF="#foot175"><SUP>1</SUP></A> project, please refer to the documentation provided with that project.

<P>
This codec will allow you to create agents, environments, and experiment programs in C and/or C++.

<P>

<H2><A NAME="SECTION00021000000000000000">
Software Requirements</A>
</H2>
This project requires that RL-Glue has been installed on your computer.  It has no additional requirements beyond RL-Glue: nothing more exotic than a C compiler, Make, etc.  This codec uses a configure script that was created by GNU Autotools<A NAME="tex2html3"
  HREF="#foot176"><SUP>2</SUP></A>, so it should compile and run without problems on most *nix platforms (Unix, Linux, Mac OS X, Windows using CYGWIN<A NAME="tex2html5"
  HREF="#foot177"><SUP>3</SUP></A>). 

<P>

<H2><A NAME="SECTION00022000000000000000">
Getting the Codec</A>
</H2>
The codec can be downloaded either as a tarball or can be checked out of the subversion repository where it is hosted.

<P>
The tarball distribution can be found here:
<BR>
<TT><A NAME="tex2html7"
  HREF="http://code.google.com/p/rl-glue-ext/downloads/list">http://code.google.com/p/rl-glue-ext/downloads/list</A></TT>
<P>
To check the code out of subversion:
<BR>
<TT>svn checkout http://rl-glue-ext.googlecode.com/svn/trunk/projects/codecs/C</TT>

<P>

<H2><A NAME="SECTION00023000000000000000">
Installing the Codec</A>
</H2>
The codec package was made with autotools, which means that you shouldn't have to do much work to get it installed.  

<P>

<H3><A NAME="SECTION00023100000000000000">
Simple Codec Install</A>
</H3>
If you are working on your own machine, it is usually easiest to install the headers and libraries into <TT>/usr/local</TT>, which is the default installation location but requires <I>sudo</I> or <I>root</I> access.

<P>
The steps are:
<PRE>
	&gt;$ ./configure
	&gt;$ make
	&gt;$ sudo make install
</PRE>

<P>
Provided everything goes well, the headers have now been installed to <TT>/usr/local/include</TT> and the libs to <TT>/usr/local/lib</TT>.

<P>

<H3><A NAME="SECTION00023200000000000000">
Install Codec when RL-Glue is in a custom location</A>
</H3>

<P>
If <TT>configure</TT> can't find RL-Glue installed on your machine, it will give you an error like the following:
<PRE>
checking for rlConnect in -lrlgluenetdev... no
configure: error: RL-Glue library not found.
You must have RL-Glue installed to use this codec. 
	
If you have not downloaded it please see http://glue.rl-community.org/
If you do have it installed in a non-standard location you may need to use the 
--with-rl-glue=/path/to/rlglue 
command line switch to specify where the rl-glue root is located.
</PRE>

<P>
If you installed RL-Glue to some place other than <TT>/usr/local</TT>, say <TT>/Users/btanner/tmp/rlglue</TT>, you could do:
<PRE>
	&gt;$ ./configure --with-rl-glue=/Users/btanner/tmp/rlglue/lib
	&gt;$ make
	&gt;$ sudo make install
</PRE>

<P>

<H3><A NAME="SECTION00023300000000000000">
Install Codec To Custom Location (without <I>root</I> access)</A>
</H3>
If you don't have <I>sudo</I> or <I>root</I> access on the target machine, you can install the codec in your home directory (or other directory you have access to).
If you install to a custom location, you will need set your <TT>CFLAGS</TT> and <TT>LDFLAGS</TT> variables appropriately when compiling your agents, environments, and experiments. See Section <A HREF="#sec:custom-flags">2.1</A> for more information.

<P>
For example, maybe we want to install the codec to <TT>/Users/btanner/tmp/rlglue</TT>.  This will <B>not</B> clobber RL-Glue if it is already installed to this location, it will install beside it.  The commands are:
<PRE>
	&gt;$ ./configure --prefix=/Users/btanner/tmp/rlglue
	&gt;$ make
	&gt;$ make install
</PRE>

<P>
Provided everything goes well, the headers and libraries have been respectively installed to
<BR>
<TT>/Users/btanner/tmp/rlglue/include</TT> and <TT>/Users/btanner/tmp/rlglue/lib</TT>.

<P>

<H1><A NAME="SECTION00030000000000000000">
Agents</A>
</H1>
We have provided a skeleton agent with the codec that is a good starting point for agents that you may write in the future.
It implements all the required functions and provides a good example of how to compile a simple agent.

<P>
The pertinent files are:
<PRE>
	examples/skeleton_agent/SkeletonAgent.c
	examples/skeleton_agent/Makefile
</PRE>

<P>
This agent is not particularly interesting, it does not learn anything and always returns the integer action 0.  

<P>
If RL-Glue and this codec have been installed in the default location, <TT>/usr/local</TT>, then you can compile and run the agent like:
<PRE>
	&gt;$ cd examples/skeleton_agent
	&gt;$ make
	&gt;$ ./SkeletonAgent
</PRE>

<P>
You will see something like:
<PRE>
	RL-Glue C Agent Codec Version 1.0-alpha-3, Build 192:208M
		Connecting to host=127.0.0.1 on port=4096...
</PRE>

<P>
This means that the SkeletonAgent is running, and trying to connect to the <TT>rl_glue</TT> executable server on the local machine through port 4096! 

<P>
See Section <A HREF="#sec:custom-flags">2.1</A> if RL-Glue or this Codec are not installed in default locations.

<P>
The Skeleton agent is very simple and well documented, so we won't spend any more time talking about it in these instructions.
Please open it up and take a look.

<P>
<B>POSSIBLE CONTRIBUTION</B>: If you take a look at the agent and you think it's not easy to understand, think it could be better documented, 
or just that it should do some fancier things, let us know and we'll be happy to do it!

<P>
We will spend a little bit talking about how to compile the agent, because not everyone is comfortable with using a <TT>Makefile</TT>.  To compile
the agent from the command line, you could do:
<PRE>
	&gt;$ cc SkeletonAgent.c -lrlutils -lrlagent -o SkeletonAgent
</PRE>

<P>
On some platforms, you may need to add <TT>-lrlgluenetdev</TT>.

<P>
It might be useful to break this down a little bit:
<DL>
<DT><STRONG>cc</STRONG></DT>
<DD>The C compiler.  You could also use <TT>gcc</TT> or <TT>g++</TT>, etc.
</DD>
<DT><STRONG>SkeletonAgent.c</STRONG></DT>
<DD>Compile the SkeletonAgent.c source file.
</DD>
<DT><STRONG>-lrlutils</STRONG></DT>
<DD>Link to the RLUtils library, which comes with this codec.  This library contains convenience functions for allocating and cleaning up the structure types (Section <A HREF="#sec:structure-types">4.3</A>).  If you 
don't use these convenience functions, you don't need this library.
</DD>
<DT><STRONG>-lrlagent</STRONG></DT>
<DD>Link to the RLAgent library of the codec.  This is where the main agent loop is defined. The main agent loop connects to the <TT>rl_glue</TT> executable server and dispatches commands sent by the glue.
</DD>
<DT><STRONG>-lrlgluenetdev</STRONG></DT>
<DD>Link to the RLGlueNetDev library from the RL-Glue project.  This library is automatically linked through <TT>rlagent</TT> on most platform (except notably Cygwin).  
RLGlueNetDev provides implementations of the low level network code that is used by all three parts of the codec, as well as the <TT>rl_glue</TT> executable server.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00031000000000000000"></A>
<A NAME="sec:custom-flags"></A>
<BR>
Custom Flags for Custom Installs
</H2>
If RL-Glue <B>or</B> this codec have been installed in a custom location (for example: <TT>/Users/joe/glue</TT>), then you will
need to set the header search path in <TT>CFLAGS</TT> and the library search path in <TT>LDFLAGS</TT>.  You can either do this each time you call make, 
or you can export the values as environment variables.  These instructions apply to agents, environments, and experiment programs.

<P>
To do it on the command line:
<PRE>
&gt;$ CFLAGS=-I/Users/joe/glue LDFLAGS=-L/Users/joe/glue make
</PRE>

<P>
That might turn out to be quite a hassle while you are developing.  In that case, you can either update the <TT>Makefile</TT> to include these flags, 
or set an environment variable.  If you are using the bash shell you can <TT>export</TT> the environment variables:
<PRE>
&gt;$ export CFLAGS=-I/Users/joe/glue
&gt;$ export LDFLAGS=-L/Users/joe/glue
&gt;$ make
</PRE>

<P>
When you open a new terminal window, these values will be lost unless you put the appropriate <TT>export</TT> lines in your shell startup script.  But that's enough about that, because
we're getting well off topic.

<P>

<H1><A NAME="SECTION00040000000000000000">
Who creates and frees memory?</A>
</H1>
- Copy-when-keep

<P>

<H1><A NAME="SECTION00050000000000000000">
Codec Specification Reference</A>
</H1>
This section will explain how the RL-Glue types and functions are defined for this codec.  This isn't meant to be an interesting section of this document, but it will
be handy.

<P>

<H2><A NAME="SECTION00051000000000000000">
Types</A>
</H2>
The types used by this codec are the same as the direct-compile RL-Glue library.

<P>

<H2><A NAME="SECTION00052000000000000000">
Simple Types</A>
</H2>
The simple types are:

<P>
<PRE>
	typedef double reward_t;
	typedef int terminal_t;
	typedef char* message_t;
	typedef char* task_specification_t;
</PRE>

<P>

<H2><A NAME="SECTION00053000000000000000"></A>
<A NAME="sec:structure-types"></A>
<BR>
Structure Types
</H2>
All of the major structure types (observations, actions, random seed keys, and state keys) are typedef'd to <TT>rl_abstract_type_t </TT>.

<P>
<PRE>
typedef struct
{
	unsigned int numInts;
	unsigned int numDoubles;
	unsigned int numChars;
	int* intArray;
	double* doubleArray;
	char* charArray;
} rl_abstract_type_t;
</PRE>

<P>
The specific names and definitions of the structure types are:
<PRE>
	typedef rl_abstract_type_t observation_t;
	typedef rl_abstract_type_t action_t;
	typedef rl_abstract_type_t random_seed_key_t;
	typedef rl_abstract_type_t state_key_t;
</PRE>

<P>
The composite structure types returned by <TT>env_step</TT> are:
<PRE>
	typedef struct{
	  observation_t o;
	  action_t a;
	} observation_action_t;

	typedef struct
	{
	  reward_t r;
	  observation_t o;
	  terminal_t terminal;
	} reward_observation_t;

	typedef struct {
	  reward_t r;
	  observation_t o;
	  action_t a;
	  terminal_t terminal;
	} reward_observation_action_terminal_t;
</PRE>

<P>

<H2><A NAME="SECTION00054000000000000000">
Summary</A>
</H2>
The type names are:
<PRE>
	reward_t
	terminal_t
	message_t
	task_specification_t
	observation_t
	action_t
	observation_action_t
	reward_observation_t
	reward_observation_action_t
</PRE>

<P>

<H1><A NAME="SECTION00060000000000000000">
Changes and 2.x Backward Compatibility</A>
</H1>

<H2><A NAME="SECTION00061000000000000000">
Types</A>
</H2>
All of the types that existed in the 2.x codec (ex: <TT>Observation</TT> instead of <TT>observation_t</TT>) are still supported through a definition file called 
<TT>legacy_types.h</TT>.  If you don't want to update your old agents to the new types, you can use the old names by doing the following in your source files:
<PRE>
	#include&lt;rlglue/legacy_types.h&gt;
</PRE>

<P>

<H2><A NAME="SECTION00062000000000000000">
C/C++ Environments</A>
</H2>
what files to include
<BR>
declaring, initializing and using the obs and action types
<BR>
special considerations
<BR>
sample environment
<BR>
<P>

<H1><A NAME="SECTION00070000000000000000">
Writing an Agent</A>
</H1>

<H2><A NAME="SECTION00071000000000000000">
C/C++ Agents</A>
</H2>

<P>

<H1><A NAME="SECTION00080000000000000000"></A>
<A NAME="exp"></A>
<BR>
Writing an Experiment
</H1>
Usually the shortest and easiest part of writing your first learning experiment is writing the experiment program. The experiment program has no interface to implement and is mostly comprised of calls to the already existing RL-Glue functions. The experiment program has four main duties: a) start the experiment b) specify how many times to run the experiment c) extract data and possibly analyze d) end the experiment and clean up.  One thing to note is that it is only the RL-Glue interface functions available to the experiment program. No agent or environment implemented functions should be directly accessed by the experiment program.

<P>

<H2><A NAME="SECTION00081000000000000000">
Basic Experiment Programs</A>
</H2>
At a minimum the experiment program must call RL_init and RL_cleanup and execute several time steps of agent-environment interaction. The following pseudo code represents a simple experiment program.
<PRE><TT>
1. RL_init()
<BR>
2. RL_start()
<BR>
3. steps=0
<BR>
4. terminal=false 
<BR>
5. <B>while</B> steps &lt; 100 <B>and not</B> terminal
<BR>
6.		 terminal,reward,observation,action = RL_step()
<BR>
7. RL_cleanup()
</TT></PRE>
This experiment program initializes the agent and environment (RL_init), calls the start functions of the agent and environment (RL_start) and then executes a 100 or less step episode. 

<P>
The RL_step function calls the env_step function passing it the most recent agent action (in this case from agent_start). The env_step function returns the new observation, reward and terminal flag. If the flag <B>is not</B> set the agent_step function is called with the new observation and reward as input arguments. The action returned by agent_step is stored by RL-Glue until the next call to RL_step. If the flag <B>is</B> set, the agent_end function is called with the reward as input. This process continues until either the flag is set or 100 steps are completed. 

<P>
Using the RL_step function gives the experiment program designer access to all the data produced during an episode; however, it is often more convient to use the RL_episode function when step-level control is not needed. Lines 5 and 6, in the above experiment program, can be replaced by a single call to RL_episode(100). If the input to RL_episode is zero, control will return to the experiment program if and only if the environment enters a terminal state.

<P>
The RL_step function allows the experiment program to record/sum/average the reward, but the RL_episode function returns no values. The RL_return and RL_num_steps functions allow the experiment program to obtain reward and number of steps taken. Specifically, RL_return returns the sum of rewards accumulated during the current or most recently completed episode. The RL_num_steps returns the number of steps elapsed during the current or most recently completed episode. 

<P>
Putting these new functions together we can write a more useful experiment program:
<PRE><TT>
1. RL_init()
<BR>
2. theReturn = 0
<BR>
3. <B>for</B> 1 = 1:100
<BR>
4. 		 RL_episode(1000)
<BR>
5. 		 theReturn += RL_return()
<BR>
6.  <B>Print</B> theReturn/100
<BR>
7. RL_cleanup()
</TT></PRE>
The above experiment program runs 100 episodes, each with max length 1000, and computes the average cumulative reward per episode.

<H2><A NAME="SECTION00082000000000000000">
Advanced Experiment Programs</A>
</H2>

<P>
As you know from previous sections (about agent and environment programs) there are several optional agent and environment functions that provide more advanced control. These functions are access through calls to the RL-Glue interface from an experiment program. For example, to send a message to the agent use RL_agent_message. To get the state key from the environment use RL_get_state. The pattern is simple to follow:
<BR>
<BR>
<P>
<DIV ALIGN="CENTER">
RL_set_state() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> env_set_state()
<BR>
RL_get_random_seed() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> env_get_random_seed()
<BR>
RL_set_random_seed() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> env_set_random_seed()
<BR>
RL_env_message() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> env_message
<BR>
</DIV>
We can now produce more advanced experiment programs that would be used in reinforcement learning research:
<PRE><TT>
1. RL_init()
<BR>
2. numSteps = 0
<BR>
3. <B>for</B> 1 = 1:1000
<BR>
4. 		 RL_episode(1000)
<BR>
5. RL_agent_message("freezeAgentPolicy")
<BR>
6. <B>for</B> 1 = 1:100
<BR>
7. 		 RL_episode(1000)
<BR>
8. 		 numSteps += RL_num_steps()
<BR>
9.  <B>Print</B> numSteps/100
<BR>
10. RL_cleanup()
</TT></PRE>

<P>

<H2><A NAME="SECTION00083000000000000000">
Components Of A RL-Glue Experiment</A>
</H2>

<H2><A NAME="SECTION00084000000000000000">
C/C++ Experiments</A>
</H2>

<H2><A NAME="SECTION00085000000000000000">
Java Experiments</A>
</H2>

<H2><A NAME="SECTION00086000000000000000">
Python Experiments</A>
</H2>

<H2><A NAME="SECTION00087000000000000000">
Matlab Experiments</A>
</H2>

<P>

<H1><A NAME="SECTION00090000000000000000">
Error Messages</A>
</H1>

<H1><A NAME="SECTION000100000000000000000">
Command and Function Reference</A>
</H1>

<P>

<H2><A NAME="SECTION000101000000000000000">
Agent Functions</A>
</H2>

<P>
Every agent must define all of the following routines. Note these functions are only accessed by the RL-Glue. Experiment programs should not try to bypass the Glue and directly access these functions.

<BR>
<BR>
agent_start:  agent_start(first_observation) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> first_action
<BR>
Given the first_observation (the observation of the agent in the start state) the agent must then return the action it wishes to perform. This is called once if the task is continuing, else it happens at the beginning of each episode.

<BR>
<BR>
agent_step: agent_step( reward, observation) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> action
<BR>
This is the most important function of the agent. Given the reward garnered by the agent's previous action, and the resulting observation, choose the next action to take. Any learning (policy improvement) should be done through this function.

<BR>
<BR>
agent_end: agent_end(reward)
<BR>
If the agent is in an episodic environment, this function will be called after the terminal state is entered. This allows for any final learning updates. If the episode is terminated prematurely (ie a benchmark cutoff before entering a terminal state) agent_end is NOT called.

<BR>
<BR>
agent_init: agent_init(task_specification)
<BR>
This function will be called first, even before agent_start. The task_specification is a description of important experiment information, including but not exclusive to a description of the state and action space. The RL-Glue standard for writing task_specification strings is found here.  In agent_init, information about the environment is extracted from the task_specification and then used to set up any necessary resources (for example, initialize the value function to a prelearning state).

<BR>
<BR>
agent_cleanup: agent_cleanup()
<BR>
This function is called at the end of a run/trial and can be used to free any resources which may have allocated in agent_init. Calls to agent_cleanup should be in a one to one ratio with the calls to agent_init.

<BR>
<BR>
agent_freeze: agent_freeze()
<BR>
Signals to the agent that training has ended. Requests that the agent freeze its current policy and value function (ie: stops learning and exploration).

<BR>
<BR>
agent_message:agent_message(input_message) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> output_message
<BR>
The agent_message function is a jack of all trades and master of none. Having no particular functionality, it is up to the user to determine what agent_message should implement. If there is any information which needs to be passed in or out of the agent, this message should do it. For example, if it is desirable that an agent's learning parameters be tweaked mid experiment, the author could establish an input string that triggers this action. Likewise, if the author wished to extract a representation of the value function, they could establish an input string which would cause agent_message to return the desired information.

<P>

<H2><A NAME="SECTION000102000000000000000">
Environment Functions</A>
</H2>

<P>
Every environment must define all of the following routines. Note these functions are only accessed by the RL-Glue. Experiment programs should not try to bypass the Glue and directly access these functions.

<BR>
<BR>
env_start: env_start() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> first_observation
<BR>
For a continuing task this is done once. For an episodic task, this is done at the beginning of each episode. Env_start assembles a first_observation given the agent is in the start state. Note the start state cannot also be a terminal state.

<BR>
<BR>
env_step: env_step(action) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> reward, observation, terminal
<BR>
Complete one step in the environment. Take the action passed in and determine what the reward and next state are for that transition.

<BR>
<BR>
env_init: env_init() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> task_specification
<BR>
This routine will be called exactly once for each trial/run. This function is an ideal place to initialize all environment information and allocate any resources required to represent the environment. It must return a task_specification which adheres to the task specification language. A task_specification stores information regarding the observation and action space, as well as whether the task is episodic or continuous.

<BR>
<BR>
env_get_state: env_get_state() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> state_key
<BR>
The state_key is a compact representation of the current state of the environment such that at any point in the future, provided with the state_key, the environment could return to thatstate. Note that this does not include the agent's value function, it is merely restoring the details of the environment. For example, in a static grid world this would be as simple as the position of the agent.

<BR>
<BR>
env_set_state: env_set_state(state_key)
<BR>
Given the state_key, the environment should return to it's exact formation when the state_key was obtained. 

<BR>
<BR>
env_get_random_seed: env_get_random_seed() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> random_seed_key
<BR>
Saves the random seed object used by the environment such that it can be restored upon presentation of random_seed_key.

<BR>
<BR>
env_set_random_seed: env_set_random_seed(random_seed_key)
<BR>
Sets the random seed used by the environment. Typically it is advantageous for the experiment program to control the randomness of the environment. Env_set_random_seed can be used in conjunction with env_set state to save and restore a random_seed such that the environment will behave exactly the same way it has previously when it was in this state and given the same actions.

<BR>
<BR>
env_cleanup: env_cleanup()
<BR>
This can be used to release any allocated resources. It will be called once for every call to env_init.

<BR>
<BR>
env_message:env_message(input_string) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> output_string
<BR>
Similar to agent_message, this function allows for any message passing to the environment required by the experiment program. This may be used to modify the environment mid experiment. Any information that needs to passed in or out of the environment can be handled by this function.

<P>

<H2><A NAME="SECTION000103000000000000000">
Interface Routines Provided by the RL-Glue</A>
</H2>

<P>
The following built in RL-Glue functions are provided primarily for the use of the experiment program writers. Using these functions, the experiment program gains access to the corresponding environment and agent functions. The implementation of these routines are to be standard across all RL-Glue users. To ensure agents/environments/experiment programs can be exchanged between authors with no changes necessary, users should not change the RL-Glue interface code provided.

<BR>
<BR>
To understand the following, it is helpful to think of an episode as consisting of sequences of observations, actions, and rewards that are indexed by time-step as follows:

<P>
o0, a0,  r1, o1, a1,  r2, o2, a2, ..., rT, terminal_observation

<BR>
<BR>
where the episode lasts T time steps (T may be infinite) and terminal_observation is a special, designated observation signaling the end of the episode.
<PRE><TT>
RL_init() 
<BR>
agent_init(env_init())
</TT></PRE>
This initializes everything, passing the environment's task_specification to the agent. This should be called at the beginning of every trial.
<PRE><TT>
RL_start() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> o0, a0
<BR>
global upcoming_action
<BR>
o = env_start()
<BR>
a = agent_start(o)
<BR>
upcoming_action = a
<BR>
return o,a
</TT></PRE>

<P>
Do the first step of a run or episode.  The action is saved in upcoming_action so that it can be used on the next step.
<PRE><TT>
RL_step() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> rt, ot, terminal, at
<BR>
global upcoming_action
<BR>
r,o,terminal = env_step(upcoming_action)
<BR>
if terminal == true
<BR>
agent_end(r)
<BR>
return r, o,terminal
<BR>
else
<BR>
a = agent_step(r, o)
<BR>
upcoming_action = a
<BR>
return r, o, terminal, a
</TT></PRE>
Take one step.  RL_step uses the saved action and saves the returned action for the next step.  The action returned from one call must be used in the next, so it is better to handle this implicitly so that the user doesn't have to keep track of the action.  If the end-of-episode observation occurs, then no action is returned.
<PRE><TT>
 RL_episode(steps)
<BR>
num_steps = 0
<BR>
o, a = RL_start()
<BR>
num_steps = num_steps + 1
<BR>
list = [o, a]
<BR>
while o <IMG
 WIDTH="18" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$\neq$"> terminal_observation
<BR>
if(steps <IMG
 WIDTH="18" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$\neq$"> 0 and num_steps <IMG
 WIDTH="18" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$\geq$"> steps)
<BR>
end
<BR>
else
<BR>
r, o, a = RL_step()
<BR>
list = list + [r, o, a]
<BR>
num_steps = num_steps + 1
<BR>
agent_end(r)
<BR>
</TT></PRE>
Do one episode until a termination observation occurs or until steps steps have elapsed, whichever comes first.  As you might imagine, this is done by calling RL_start, then RL_step until the terminal observation occurs.  If steps is set to 0, it is taken to be the case where there is no limitation on the number of steps taken and RL_episode will continue until a termination observation occurs. If no terminal observation is reached before num_steps is reached, the agent does not call agent_end, it simply stops.

<BR>
<BR>
RL_return() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> return

<BR>
<BR>
Return the cumulative total reward of the current or just completed episode.  The collection of all the rewards received in an episode (the return) is done within RL_return however, any discounting of rewards must be done inside the environment or agent.

<BR>
<BR>
RL_num_steps() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> num_steps

<BR>
<BR>
Return the number of steps elapsed in the current or just completed episode.
<PRE><TT>
RL_cleanup()
<BR>
env_cleanup()
<BR>
agent_cleanup()
</TT></PRE>
Provides an opportunity to reclaim resources allocated by RL_init.
<PRE><TT>
RL_set_state(State_key)
<BR>
env_set_state(State_key) 
</TT></PRE>
Provides an opportunity to reset the state (see env_set_state for details).
<PRE><TT>
RL_set_random_seed(Random_seed_key)
<BR>
env_set_random_seed(Random_seed_key)
</TT></PRE>
Provides an opportunity to reset the random seed key (see env_set_random_seed for details).
<PRE><TT>
RL_get_state() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> State_key
<BR>
return env_get_state() 
</TT></PRE>
Provides an opportunity to extract the state key from the environment (see env_get_state for details).
<PRE><TT>
RL_get_random_seed() <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> Random_seed_key
<BR>
return env_get_random_seed() 
</TT></PRE>
Provides an opportunity to extract the random seed key from the environment (see env_get_random_seed for details).               
<PRE><TT>
RL_agent_message(input_message_string) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> output_message_string
<BR>
return agent_message(input_message_string)
</TT></PRE>
This message passes the input string to the agent and returns the reply string given by the agent. See agent_message for more details.                
<PRE><TT>
RL_env_message(input_message_string) <IMG
 WIDTH="22" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> output_message_string
<BR>
return env_message(input_message_string)
</TT></PRE>
This message passes the input string to the environment and returns the reply string given by the environment. See env_message for more details. 

<P>
<A NAME="ref"></A>
<H1><A NAME="SECTION000110000000000000000">
Frequently Asked Questions</A>
</H1>

<H1><A NAME="SECTION000120000000000000000">
Glossary</A>
</H1>

<P>

<H1><A NAME="SECTION000130000000000000000">
Credits and Acknowledgements</A>
</H1>
Thanks to everyone for testing the code, and for helping out.

<P>

<H2><A NAME="SECTION000131000000000000000">
Contributing</A>
</H2>
If you would like to become a member of this project and contribute updates/changes to the code, please send a message to rl-glue@googlegroups.com.

<H1><A NAME="SECTION000140000000000000000">
About this document ...</A>
</H1>
 <STRONG>RL-Glue C/C++ Codec 3.0 Manual <I>Revision</I>: 206</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002-2-1 (1.71)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>doc.tex -split 0 -dir html -mkdir -title 'RL-Glue C/C++ Codec' -local_icons -math</TT>
<P>
The translation was initiated by Brian Tanner on 2008-09-28
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot175">... RL-Glue</A><A
 HREF="doc.html#tex2html1"><SUP>1</SUP></A></DT>
<DD><TT><A NAME="tex2html2"
  HREF="http://glue.rl-community.org/">http://glue.rl-community.org/</A></TT>

</DD>
<DT><A NAME="foot176">... Autotools</A><A
 HREF="doc.html#tex2html3"><SUP>2</SUP></A></DT>
<DD><TT><A NAME="tex2html4"
  HREF="http://sources.redhat.com/autobook/">http://sources.redhat.com/autobook/</A></TT>

</DD>
<DT><A NAME="foot177">... CYGWIN</A><A
 HREF="doc.html#tex2html5"><SUP>3</SUP></A></DT>
<DD><TT><A NAME="tex2html6"
  HREF="http://www.cygwin.com/">http://www.cygwin.com/</A></TT>

</DD>
</DL><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.png">   
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
Brian Tanner
2008-09-28
</ADDRESS>
</BODY>
</HTML>
